{"version":3,"sources":["checkLegacyPathConfig.tsx"],"names":["checkLegacyPathConfig","config","legacy","Object","keys","some","key","hasOwnProperty","Error","screens"],"mappings":";;;;;;;AAOe,SAASA,qBAAT,CACbC,MADa,EAEmB;AAChC,MAAIC,MAAM,GAAG,KAAb;;AAEA,MAAID,MAAJ,EAAY;AACV;AACAC,IAAAA,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYH,MAAZ,EAAoBI,IAApB,CACNC,GAAD,IAASA,GAAG,KAAK,SAAR,IAAqBA,GAAG,KAAK,kBAD/B,CAAT;;AAIA,QACEJ,MAAM,KACLD,MAAM,CAACM,cAAP,CAAsB,SAAtB,KACCN,MAAM,CAACM,cAAP,CAAsB,kBAAtB,CAFI,CADR,EAIE;AACA,YAAM,IAAIC,KAAJ,CACJ,oKADI,CAAN;AAGD;AACF;;AAED,MAAIN,MAAJ,EAAY;AACV;AACA,WAAO,CAACA,MAAD,EAAS;AAAEO,MAAAA,OAAO,EAAER;AAAX,KAAT,CAAP;AACD;;AAED,SAAO,CAACC,MAAD,EAASD,MAAT,CAAP;AACD","sourcesContent":["import type { PathConfigMap } from './types';\n\ntype Options = {\n  initialRouteName?: string;\n  screens: PathConfigMap;\n};\n\nexport default function checkLegacyPathConfig(\n  config?: Options\n): [boolean, Options | undefined] {\n  let legacy = false;\n\n  if (config) {\n    // Assume legacy configuration if config has any other keys except `screens` and `initialRouteName`\n    legacy = Object.keys(config).some(\n      (key) => key !== 'screens' && key !== 'initialRouteName'\n    );\n\n    if (\n      legacy &&\n      (config.hasOwnProperty('screens') ||\n        config.hasOwnProperty('initialRouteName'))\n    ) {\n      throw new Error(\n        'Found invalid keys in the configuration object. See https://reactnavigation.org/docs/configuring-links/ for more details on the shape of the configuration object.'\n      );\n    }\n  }\n\n  if (legacy) {\n    // @ts-expect-error: we have incorrect type for config since we don't type legacy config\n    return [legacy, { screens: config }];\n  }\n\n  return [legacy, config];\n}\n"]}